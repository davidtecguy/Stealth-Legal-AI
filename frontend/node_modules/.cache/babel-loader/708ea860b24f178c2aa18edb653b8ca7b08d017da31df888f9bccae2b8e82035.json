{"ast":null,"code":"const API_BASE_URL = 'http://localhost:8000';\nclass ApiService {\n  constructor() {\n    this.baseUrl = API_BASE_URL;\n  }\n  async request(endpoint, options = {}) {\n    const url = `${this.baseUrl}${endpoint}`;\n    const response = await fetch(url, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      },\n      ...options\n    });\n    if (!response.ok) {\n      const error = await response.json().catch(() => ({\n        error: 'Unknown error'\n      }));\n      throw new Error(error.error || `HTTP error! status: ${response.status}`);\n    }\n    if (response.status === 204) {\n      return {}; // No content\n    }\n    return response.json();\n  }\n\n  // Document CRUD operations\n  async createDocument(document) {\n    return this.request('/documents', {\n      method: 'POST',\n      body: JSON.stringify(document)\n    });\n  }\n  async getDocuments(skip = 0, limit = 100) {\n    return this.request(`/documents?skip=${skip}&limit=${limit}`);\n  }\n  async getDocument(id) {\n    return this.request(`/documents/${id}`);\n  }\n  async updateDocument(id, changes, etag) {\n    const headers = {};\n    if (etag) {\n      headers['If-Match'] = etag;\n    }\n    return this.request(`/documents/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(changes),\n      headers\n    });\n  }\n  async deleteDocument(id) {\n    return this.request(`/documents/${id}`, {\n      method: 'DELETE'\n    });\n  }\n\n  // Search operations\n  async searchDocuments(query, limit = 10, offset = 0) {\n    return this.request(`/documents/search?q=${encodeURIComponent(query)}&limit=${limit}&offset=${offset}`);\n  }\n  async searchDocument(id, query, limit = 10, offset = 0) {\n    return this.request(`/documents/${id}/search?q=${encodeURIComponent(query)}&limit=${limit}&offset=${offset}`);\n  }\n\n  // Health check\n  async healthCheck() {\n    return this.request('/health');\n  }\n\n  // LLM Legal AI Methods\n  async analyzeDocumentLLM(documentId) {\n    const response = await fetch(`${this.baseUrl}/documents/${documentId}/analyze`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`LLM Analysis failed: ${response.statusText}`);\n    }\n    return response.json();\n  }\n  async improveDocumentLLM(documentId, improvementType, specificFocus) {\n    const request = {\n      document_id: documentId,\n      improvement_type: improvementType,\n      specific_focus: specificFocus\n    };\n    const response = await fetch(`${this.baseUrl}/documents/${documentId}/improve`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(request)\n    });\n    if (!response.ok) {\n      throw new Error(`Document improvement failed: ${response.statusText}`);\n    }\n    return response.json();\n  }\n  async semanticSearch(query, limit = 10, offset = 0) {\n    const response = await fetch(`${this.baseUrl}/documents/semantic-search?q=${encodeURIComponent(query)}&limit=${limit}&offset=${offset}`);\n    if (!response.ok) {\n      throw new Error(`Semantic search failed: ${response.statusText}`);\n    }\n    return response.json();\n  }\n  async classifyDocumentLLM(documentId) {\n    const response = await fetch(`${this.baseUrl}/documents/${documentId}/classify`);\n    if (!response.ok) {\n      throw new Error(`Document classification failed: ${response.statusText}`);\n    }\n    return response.json();\n  }\n  async extractLegalTermsLLM(documentId) {\n    const response = await fetch(`${this.baseUrl}/documents/${documentId}/extract-terms`);\n    if (!response.ok) {\n      throw new Error(`Legal term extraction failed: ${response.statusText}`);\n    }\n    return response.json();\n  }\n  async getLLMStatus() {\n    const response = await fetch(`${this.baseUrl}/llm/status`);\n    if (!response.ok) {\n      throw new Error(`LLM status check failed: ${response.statusText}`);\n    }\n    return response.json();\n  }\n}\nexport const apiService = new ApiService();","map":{"version":3,"names":["API_BASE_URL","ApiService","constructor","baseUrl","request","endpoint","options","url","response","fetch","headers","ok","error","json","catch","Error","status","createDocument","document","method","body","JSON","stringify","getDocuments","skip","limit","getDocument","id","updateDocument","changes","etag","deleteDocument","searchDocuments","query","offset","encodeURIComponent","searchDocument","healthCheck","analyzeDocumentLLM","documentId","statusText","improveDocumentLLM","improvementType","specificFocus","document_id","improvement_type","specific_focus","semanticSearch","classifyDocumentLLM","extractLegalTermsLLM","getLLMStatus","apiService"],"sources":["/home/magic/Work/Workspace/Stealth_Legal-AI/frontend/src/services/api.ts"],"sourcesContent":["import { \n  Document, \n  DocumentCreate, \n  DocumentChanges, \n  SearchResponse \n} from '../types';\n\nconst API_BASE_URL = 'http://localhost:8000';\n\nclass ApiService {\n  private baseUrl = API_BASE_URL;\n\n  private async request<T>(\n    endpoint: string, \n    options: RequestInit = {}\n  ): Promise<T> {\n    const url = `${this.baseUrl}${endpoint}`;\n    const response = await fetch(url, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n      ...options,\n    });\n\n    if (!response.ok) {\n      const error = await response.json().catch(() => ({ error: 'Unknown error' }));\n      throw new Error(error.error || `HTTP error! status: ${response.status}`);\n    }\n\n    if (response.status === 204) {\n      return {} as T; // No content\n    }\n\n    return response.json();\n  }\n\n  // Document CRUD operations\n  async createDocument(document: DocumentCreate): Promise<Document> {\n    return this.request<Document>('/documents', {\n      method: 'POST',\n      body: JSON.stringify(document),\n    });\n  }\n\n  async getDocuments(skip = 0, limit = 100): Promise<Document[]> {\n    return this.request<Document[]>(`/documents?skip=${skip}&limit=${limit}`);\n  }\n\n  async getDocument(id: number): Promise<Document> {\n    return this.request<Document>(`/documents/${id}`);\n  }\n\n  async updateDocument(id: number, changes: DocumentChanges, etag?: string): Promise<Document> {\n    const headers: Record<string, string> = {};\n    if (etag) {\n      headers['If-Match'] = etag;\n    }\n\n    return this.request<Document>(`/documents/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(changes),\n      headers,\n    });\n  }\n\n  async deleteDocument(id: number): Promise<void> {\n    return this.request<void>(`/documents/${id}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // Search operations\n  async searchDocuments(query: string, limit = 10, offset = 0): Promise<SearchResponse> {\n    return this.request<SearchResponse>(\n      `/documents/search?q=${encodeURIComponent(query)}&limit=${limit}&offset=${offset}`\n    );\n  }\n\n  async searchDocument(id: number, query: string, limit = 10, offset = 0): Promise<SearchResponse> {\n    return this.request<SearchResponse>(\n      `/documents/${id}/search?q=${encodeURIComponent(query)}&limit=${limit}&offset=${offset}`\n    );\n  }\n\n  // Health check\n  async healthCheck(): Promise<{ status: string; service: string }> {\n    return this.request<{ status: string; service: string }>('/health');\n  }\n\n  // LLM Legal AI Methods\n  async analyzeDocumentLLM(documentId: number): Promise<LLMAnalysisResponse> {\n    const response = await fetch(`${this.baseUrl}/documents/${documentId}/analyze`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' }\n    });\n    \n    if (!response.ok) {\n      throw new Error(`LLM Analysis failed: ${response.statusText}`);\n    }\n    \n    return response.json();\n  }\n\n  async improveDocumentLLM(documentId: number, improvementType: string, specificFocus?: string): Promise<DocumentImprovementResponse> {\n    const request: DocumentImprovementRequest = {\n      document_id: documentId,\n      improvement_type: improvementType,\n      specific_focus: specificFocus\n    };\n\n    const response = await fetch(`${this.baseUrl}/documents/${documentId}/improve`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(request)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Document improvement failed: ${response.statusText}`);\n    }\n    \n    return response.json();\n  }\n\n  async semanticSearch(query: string, limit: number = 10, offset: number = 0): Promise<SemanticSearchResponse> {\n    const response = await fetch(`${this.baseUrl}/documents/semantic-search?q=${encodeURIComponent(query)}&limit=${limit}&offset=${offset}`);\n    \n    if (!response.ok) {\n      throw new Error(`Semantic search failed: ${response.statusText}`);\n    }\n    \n    return response.json();\n  }\n\n  async classifyDocumentLLM(documentId: number): Promise<DocumentClassification> {\n    const response = await fetch(`${this.baseUrl}/documents/${documentId}/classify`);\n    \n    if (!response.ok) {\n      throw new Error(`Document classification failed: ${response.statusText}`);\n    }\n    \n    return response.json();\n  }\n\n  async extractLegalTermsLLM(documentId: number): Promise<LegalTerm[]> {\n    const response = await fetch(`${this.baseUrl}/documents/${documentId}/extract-terms`);\n    \n    if (!response.ok) {\n      throw new Error(`Legal term extraction failed: ${response.statusText}`);\n    }\n    \n    return response.json();\n  }\n\n  async getLLMStatus(): Promise<LLMStatus> {\n    const response = await fetch(`${this.baseUrl}/llm/status`);\n    \n    if (!response.ok) {\n      throw new Error(`LLM status check failed: ${response.statusText}`);\n    }\n    \n    return response.json();\n  }\n}\n\nexport const apiService = new ApiService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}